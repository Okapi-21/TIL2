## 責務の分離

------

Laravelは理解しやすく、動きやすいフレームワークである反面、Controller や Model に直接ロジックを書きすぎてしまうケースもよくみられる。

例えば、以下のようなケースである。

```php
public function store(Request $request)
{
    // バリデーション
    $validated = $request->validate([
        'title' => 'required|string|max:255',
        'content' => 'required|string',
        'category_id' => 'required|exists:categories,id',
        'tags' => 'array',
        'tags.*' => 'exists:tags,id'
    ]);

    // DBトランザクション開始
    DB::beginTransaction();
    
    try {
        // 投稿作成
        $post = new Post();
        $post->title = $validated['title'];
        $post->content = $validated['content'];
        $post->category_id = $validated['category_id'];
        $post->user_id = auth()->id();
        $post->slug = Str::slug($validated['title']);
        $post->published_at = now();
        $post->save();

        // タグの関連付け
        if (isset($validated['tags'])) {
            $post->tags()->attach($validated['tags']);
        }

        // キャッシュクリア
        Cache::forget('posts_list');
        Cache::forget('user_posts_' . auth()->id());

        // 通知送信
        $followers = auth()->user()->followers;
        Notification::send($followers, new PostPublished($post));

        // アクティビティログ記録
        activity()
            ->performedOn($post)
            ->causedBy(auth()->user())
            ->withProperties(['title' => $post->title])
            ->log('投稿を作成しました');

        // SEOメタデータ生成
        $post->meta()->create([
            'meta_title' => $post->title . ' | ' . config('app.name'),
            'meta_description' => Str::limit($post->content, 160),
            'og_image' => asset('images/default-og.jpg')
        ]);

        DB::commit();

        // Slackに通知
        Log::channel('slack')->info("新規投稿: {$post->title}", [
            'user' => auth()->user()->name,
            'post_id' => $post->id
        ]);

        return redirect()->route('posts.show', $post)
            ->with('success', '投稿を公開しました');

    } catch (\Exception $e) {
        DB::rollback();
        Log::error('投稿作成エラー', ['error' => $e->getMessage()]);
        
        return back()->withInput()
            ->with('error', '投稿の作成に失敗しました');
    }
}
```

このようなコードは以下のような問題を抱えている。

1. #### 責任の所在が不明確：バリデーション、ビジネスロジック、DB操作、通知などあらゆる責務が混在している

2. #### 再利用性の欠如：API経由で投稿を作成したい場合は、同様のロジックを別のcontrollerに書く必要がある

3. #### テストの困難さ：一つのメソッドをテストするために、DB、キャッシュ、ログなどの全ての依存関係をさらう必要がある

4. #### 保守性の低下：新しい要件を追加する際には、既存のロジックに手を加える必要がある



この課題を解決するため、次のように役割を明確に分割する

### 各層の責務

1. controller 層
   - HTTPリクエストの受け取りとレスポンスの返却
   - バリデーション
   - サービス層の呼び出し
   - ビューやJSONレスポンスの生成
     
2. Service層
   - ビジネスロジックの実装
   - トランザクション制御
   - 複数のリポジトリの協調
   - 外部サービスとの連携
   - イベントの発行
     
3. Repository層
   - データの永続化と取得
   - クエリの構築
   - Eloquentモデルの操作
   - キャッシュの管理



構造としては以下のようになっている

```
app/
├── Http/
│   ├── Controllers/
│   │   └── PostController.php
│   └── Requests/
│       └── PostRequest.php
├── Services/
│   ├── PostService.php
│   └── NotificationService.php
├── Repositories/
│   ├── Interfaces/
│   │   └── PostRepositoryInterface.php
│   └── Eloquent/
│       └── PostRepository.php
├── Models/
│   └── Post.php
└── Providers/
    └── RepositoryServiceProvider.php

```

### 実装例

1. controller

```php
<?php

namespace App\Http\Controllers;

use App\Http\Requests\PostRequest;
use App\Services\PostService;
use Illuminate\Http\RedirectResponse;

class PostController extends Controller
{
    private PostService $postService;

    public function __construct(PostService $postService)
    {
        $this->postService = $postService;
    }

    public function store(PostRequest $request): RedirectResponse
    {
        try {
            $post = $this->postService->create(
                $request->validated(),
                auth()->user()
            );

            return redirect()
                ->route('posts.show', $post)
                ->with('success', '投稿を公開しました');

        } catch (\Exception $e) {
            return back()
                ->withInput()
                ->with('error', '投稿の作成に失敗しました');
        }
    }
}
```



2. FormRequest（バリデーション専用クラス）

```php
<?php

namespace App\Http\Requests;

use Illuminate\Foundation\Http\FormRequest;

class PostRequest extends FormRequest
{
    public function authorize(): bool
    {
        return true;
    }

    public function rules(): array
    {
        return [
            'title' => 'required|string|max:255',
            'content' => 'required|string',
            'category_id' => 'required|exists:categories,id',
            'tags' => 'array',
            'tags.*' => 'exists:tags,id',
        ];
    }

    public function messages(): array
    {
        return [
            'title.required' => 'タイトルは必須です',
            'content.required' => '本文は必須です',
            'category_id.exists' => '正しいカテゴリーを選択してください',
        ];
    }
}
```

3. Service層

```php
<?php

namespace App\Services;

use App\Models\Post;
use App\Models\User;
use App\Repositories\Interfaces\PostRepositoryInterface;
use App\Events\PostPublished;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class PostService
{
    private PostRepositoryInterface $postRepository;
    private NotificationService $notificationService;
    private ActivityService $activityService;
    private SeoService $seoService;

    public function __construct(
        PostRepositoryInterface $postRepository,
        NotificationService $notificationService,
        ActivityService $activityService,
        SeoService $seoService
    ) {
        $this->postRepository = $postRepository;
        $this->notificationService = $notificationService;
        $this->activityService = $activityService;
        $this->seoService = $seoService;
    }

    public function create(array $data, User $author): Post
    {
        return DB::transaction(function () use ($data, $author) {
            // 投稿データの準備
            $postData = $this->preparePostData($data, $author);
            
            // 投稿の作成
            $post = $this->postRepository->create($postData);

            // タグの関連付け
            if (!empty($data['tags'])) {
                $this->postRepository->attachTags($post, $data['tags']);
            }

            // SEOメタデータの生成
            $this->seoService->generateMetaData($post);

            // アクティビティログの記録
            $this->activityService->logPostCreation($post, $author);

            // イベントの発行（非同期処理のトリガー）
            event(new PostPublished($post));

            // キャッシュのクリア
            $this->postRepository->clearCache($author->id);

            return $post;
        });
    }

    private function preparePostData(array $data, User $author): array
    {
        return [
            'title' => $data['title'],
            'content' => $data['content'],
            'category_id' => $data['category_id'],
            'user_id' => $author->id,
            'slug' => $this->generateUniqueSlug($data['title']),
            'published_at' => now(),
        ];
    }

    private function generateUniqueSlug(string $title): string
    {
        $baseSlug = Str::slug($title);
        $count = 1;
        $slug = $baseSlug;

        while ($this->postRepository->existsBySlug($slug)) {
            $slug = "{$baseSlug}-{$count}";
            $count++;
        }

        return $slug;
    }

    public function update(Post $post, array $data): Post
    {
        // 更新ロジック
    }

    public function delete(Post $post): bool
    {
        // 削除ロジック
    }
}
```

4. Repository Interface

```php
<?php

namespace App\Repositories\Interfaces;

use App\Models\Post;
use App\Models\User;
use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Support\Collection;

interface PostRepositoryInterface
{
    public function create(array $data): Post;
    
    public function update(Post $post, array $data): Post;
    
    public function delete(Post $post): bool;
    
    public function find(int $id): ?Post;
    
    public function findBySlug(string $slug): ?Post;
    
    public function existsBySlug(string $slug): bool;
    
    public function getByUser(User $user, int $perPage = 15): LengthAwarePaginator;
    
    public function getPublished(int $perPage = 15): LengthAwarePaginator;
    
    public function searchByKeyword(string $keyword): Collection;
    
    public function attachTags(Post $post, array $tagIds): void;
    
    public function clearCache(?int $userId = null): void;
}
```

5. Repository実装

```php
<?php

namespace App\Repositories\Eloquent;

use App\Models\Post;
use App\Models\User;
use App\Repositories\Interfaces\PostRepositoryInterface;
use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Cache;

class PostRepository implements PostRepositoryInterface
{
    private const CACHE_KEY_PREFIX = 'posts';
    private const CACHE_TTL = 3600; // 1時間

    public function create(array $data): Post
    {
        return Post::create($data);
    }

    public function update(Post $post, array $data): Post
    {
        $post->update($data);
        return $post->fresh();
    }

    public function delete(Post $post): bool
    {
        return $post->delete();
    }

    public function find(int $id): ?Post
    {
        return Cache::remember(
            $this->getCacheKey("post_{$id}"),
            self::CACHE_TTL,
            fn() => Post::find($id)
        );
    }

    public function findBySlug(string $slug): ?Post
    {
        return Cache::remember(
            $this->getCacheKey("slug_{$slug}"),
            self::CACHE_TTL,
            fn() => Post::where('slug', $slug)->first()
        );
    }

    public function existsBySlug(string $slug): bool
    {
        return Post::where('slug', $slug)->exists();
    }

    public function getByUser(User $user, int $perPage = 15): LengthAwarePaginator
    {
        return Post::where('user_id', $user->id)
            ->with(['category', 'tags'])
            ->orderBy('created_at', 'desc')
            ->paginate($perPage);
    }

    public function getPublished(int $perPage = 15): LengthAwarePaginator
    {
        return Post::where('published_at', '<=', now())
            ->with(['user', 'category', 'tags'])
            ->orderBy('published_at', 'desc')
            ->paginate($perPage);
    }

    public function searchByKeyword(string $keyword): Collection
    {
        return Post::where('title', 'like', "%{$keyword}%")
            ->orWhere('content', 'like', "%{$keyword}%")
            ->with(['user', 'category'])
            ->orderBy('created_at', 'desc')
            ->limit(20)
            ->get();
    }

    public function attachTags(Post $post, array $tagIds): void
    {
        $post->tags()->sync($tagIds);
    }

    public function clearCache(?int $userId = null): void
    {
        Cache::forget($this->getCacheKey('list'));
        
        if ($userId) {
            Cache::forget($this->getCacheKey("user_{$userId}"));
        }
    }

    private function getCacheKey(string $key): string
    {
        return self::CACHE_KEY_PREFIX . ":{$key}";
    }
}
```

6. ServiceProvider （DIコンテナへの登録）

```php
<?php

namespace App\Providers;

use App\Repositories\Interfaces\PostRepositoryInterface;
use App\Repositories\Eloquent\PostRepository;
use Illuminate\Support\ServiceProvider;

class RepositoryServiceProvider extends ServiceProvider
{
    public function register(): void
    {
        $this->app->bind(
            PostRepositoryInterface::class,
            PostRepository::class
        );
    }
}
```








